# 基础知识

## 输出到命令行
### 输出字符串
#### 输出方式
Rust 输出文字的方式主要有两种：
2. `print!()`

区别在于:
- `println!`在输出的最后附加输出一个换行符
- `println` 允许打印空的字符串到新的一行，`print!`不允许 

#### println!
```rs
fn main(){
    println!(); // prints just a newline
    println!("hello there!");
    println!("My name is {}", 'json');
    println!("format {{}}");
    // There are various optional patterns this works with. Positional
    // arguments can be used.
    println!("{0}, this is {1}. {1}, this is {0}", "Alice", "Bob");
    // As can named arguments.
    println!("{subject} {verb} {object}",
             object="the lazy dog",
             subject="the quick brown fox",
             verb="jumps over");
}
```
总结：
- 使用 `{}` 作占位符
- 可以使用`{number}`指定变量位置
- 使用`{{}}`转义显示字符串`{}`


### 函数定义
``` rs
fn main() {
    let result = another_function(5, 6);
    println!("x + y = {}", result)
}

// 带有返回值的函数
fn another_function(x: i32, y: i32) -> i32 {
    println!("x 的值为 : {}", x);
    println!("y 的值为 : {}", y);
    return x + y;
}
```
总结：
-  Rust不在乎您在何处定义函数，只需在某个地方定义它们即可
-  Rust 是强类型语言，函数参数和函数返回值需要指定类型

### 定义变量
#### 声明变量
如果要声明变量，需要使用 `let` 关键字。例如：
```rs
let a = 123;
```
这样就声明了 `a` 是一个**不可变变量**。在这句声明语句之后，以下三行代码都是被禁止的：
```
a = "abc";
a = 4.56; 
a = 456;
```
- 第一行的错误在于当声明 a 是 123 以后，a 就被确定为整型数字，不能把字符串类型的值赋给它
- 第二行的错误在于自动转换数字精度有损失，Rust 语言不允许精度有损失的自动数据类型转换
- 第三行的错误在于 a 不是个可变变量

#### 使变量变得"可变"
使变量变得"可变"（mutable）只需一个 `mut` 关键字：
```rs
let mut a = 123;
a = 456;
```
#### 常量与不可变变量的区别
既然不可变变量是不可变的，那不就是常量吗？为什么叫变量？</br>
变量和常量还是有区别的。在 Rust 中，以下程序是合法的：
```rs
let a = 123;   // 可以编译，但可能有警告，因为该变量没有被使用
let a = 456;
```
但是如果 a 是常量就不合法：
```rs
const a: i32 = 123;
let a = 456;
```
变量的值可以"重新绑定"，但在"重新绑定"以前不能私自被改变，这样可以确保在每一次"绑定"之后的区域里编译器可以充分的推理程序逻辑。

#### 重影(shadowing)
重影就是指变量的名称可以被重新使用的机制。重影与可变变量的赋值不是一个概念，重影是指用同一个名字重新代表另一个变量实体，其类型、可变属性和值都可以变化。但可变变量赋值仅能发生值的变化。例如：
```rs
fn main() {
    {
        println!("before being shadowed: {}", shadowed_binding);
        // This binding *shadows* the outer one
        let shadowed_binding = "abc";
        println!("shadowed in inner block: {}", shadowed_binding);
    }
    println!("outside inner block: {}", shadowed_binding);
    // This binding *shadows* the previous binding
    let shadowed_binding = 2;
    println!("shadowed in outer block: {}", shadowed_binding);
}
```
输出：
```bash
shadowed in inner block: abc
shadowed in outer block: 2
```
下面这段程序会出错：不能给字符串变量赋整型值。
```rs
let mut s = "123";
s = s.len();
```


### Rust 数据类型
#### 整数
##### 字节长度
8/16/32/64/128 bit 
有符号: i8
无符号: u8

##### 进制
十进制 / 0xff：十六进制/0o77：八进制/字节

#### 浮点数
支持 32 位浮点数（f32）和 64 位浮点数（f64），默认情况下，64.0 将表示 64 位浮点数。

#### 布尔类型
true/false

#### 字符类型
字符型用 char 表示。Rust的 char 类型大小为 4 个字节，代表 Unicode标量值，它可以支持中文，日文和韩文字符等非英文字符甚至表情符号和零宽度空格。
在 Rust 中字符串和字符都必须使用 UTF-8 编码，否则编译器会报错。

### 复合类型
比如： 元组、数组类型

## 流程控制

### if-else
```rs
if <condition> { block 1 } else { block 2 } 
```
总结
- 条件表达式 number < 5 不需要用小括号包括（注意，不需要不是不允许）；
- Rust 中的 if 不存在单语句不用加 {} 的规则，不允许使用一个语句代替一个块

## match
提供我们用的 `switch...case` 的功能，不同的是这里是 `match... =>`,不用每个case写 `break`
```rs
fn main() {
    let number = 13;
    // TODO ^ Try different values for `number`

    println!("Tell me about {}", number);
    match number {
        // Match a single value
        1 => println!("One!"),
        // Match several values
        2 | 3 | 5 | 7 | 11 => println!("This is a prime"),
        // TODO ^ Try adding 13 to the list of prime values
        // Match an inclusive range
        13..=19 => println!("A teen"),
        // Handle the rest of cases
        _ => println!("Ain't special"),
        // TODO ^ Try commenting out this catch-all arm
    }

    let boolean = true;
    // Match is an expression too
    let binary = match boolean {
        // The arms of a match must cover all the possible values
        false => 0,
        true => 1,
        // TODO ^ Try commenting out one of these arms
    };

    println!("{} -> {}", boolean, binary);
}
```

### if let


### loop
```rs
fn main() {
    let mut count = 0u32;

    println!("Let's count until infinity!");

    // Infinite loop
    loop {
        count += 1;
        if count == 3 {
            println!("three");
            // Skip the rest of this iteration
            continue;
        }
        println!("{}", count);
        if count == 5 {
            println!("OK, that's enough");
            // Exit this loop
            break;
        }
    }
}
```
嵌套 loop:
```rs
#![allow(unreachable_code)]

fn main() {
    'outer: loop {
        println!("Entered the outer loop");
        'inner: loop {
            println!("Entered the inner loop");
            // This would break only the inner loop
            //break;

            // This breaks the outer loop
            break 'outer;
        }
        // never be reached
        println!("This point will never be reached");
    }
    println!("Exited the outer loop");
}

```
总结：
- 无限循环，可以不用预先设置条件就可以执行里面的代码,常被用来当作查找工具使用
- 支持 `break` `continue`
- 支持命名和嵌套
  
### for
```rs
fn main() {
    let a = [10, 20, 30, 40, 50];
    for i in a.iter() {
        println!("值为 : {}", i);
    }
}
```
`for...in` 常被用来遍历迭代器。语法与其他语言基本相同，不同之处是条件可以不用`()`包裹。


### while
```rs
fn main() {
    // A counter variable
    let mut n = 1;

    // Loop while `n` is less than 101
    while n < 101 {
        if n % 15 == 0 {
            println!("fizzbuzz");
        } else if n % 3 == 0 {
            println!("fizz");
        } else if n % 5 == 0 {
            println!("buzz");
        } else {
            println!("{}", n);
        }

        // Increment counter
        n += 1;
    }
}
```
与其他语言基本相同，不同之处是条件可以不用`()`包裹

## 结构体

```rs
// 定义
struct Site {
    domain: String,
    name: String,
    nation: String,
    found: u32
}

// 实例化
let runoob = Site {
    domain: String::from("www.runoob.com"),
    name: String::from("RUNOOB"),
    nation: String::from("China"),
    found: 2013
};

// 大部分属性需要被设置成与现存的一个结构体属性一样，仅需更改其中的一两个字段的值
let site = Site {
    domain: String::from("www.runoob.com"),
    name: String::from("RUNOOB"),
    ..runoob
};
```
元组结构体：
```rs
fn main() {
    // 与元组的区别是它有名字和固定的类型格式。它存在的意义是为了处理那些需要定义类型（经常使用）又不想太复杂的简单数据
    struct Color(u8, u8, u8);
    struct Point(f64, f64);

    let black = Color(0, 0, 0);
    let origin = Point(0.0, 0.0);

    println!("black = ({}, {}, {})", black.0, black.1, black.2);
    println!("origin = ({}, {})", origin.0, origin.1);
}
```
总结
- 有点像高级语言中的 class
- 与C++不同，在 Rust 里 struct 语句**仅用来定义，不能声明实例**，结尾不需要 ; 符号，而且每个字段定义之后用 , 分隔。
- 实例可以被解构

## 枚举类
越看越像是创建命名空间 emmm...
访问结构体/枚举项的方法： `::`

```rs
#[derive(Debug)]

enum Book {
    Papery, Electronic
}

fn main() {
    let book = Book::Papery;
    println!("{:?}", book); // Papery
}
```
结构体方法：
```rs
fn main() {
    // 枚举定义
    enum Book {
        PaperyTypeOne(u32),
        PaperyTypeTwo {index: u32},
        Electronic {url: String},
    }
   
    // 实例化
    let book = Book::Papery{index: 1001};
    let ebook = Book::Electronic{url: String::from("url...")};
   
   // 使用match 访问
    match book {
        Book::PaperyTypeOne(i) => {
            println!("Papery book {}", i);
        },
        Book::PaperyTypeTwo { index } => {
            println!("Papery book {}", index);
        },
        Book::Electronic { url } => {
            println!("E-book {}", url);
        }
    }
}
// 运行结果
// Papery book 1001

```

### 枚举类

## 所有权
所有权有以下三条规则：
- Rust 中的每个值都有一个变量，称为其所有者。
- 一次只能有一个所有者。
- 当所有者不在程序运行范围时，该值将被删除。

所有权与JS中作用域的概念很像。

### 变量范围
`{}` 代码块作用域：
```rs
{
    // 在声明以前，变量 s 无效
    let s = "runoob";
    // 这里是变量 s 的可用范围
}
// 变量范围已经结束，变量 s 无效
```

### 变量移动
多个变量可以在 Rust 中以不同的方式与相同的数据交互。
#### 基本类型的移动
**基本类型的移动不会影响原来的值。**

```rs
let x = 5;
let y = x;
```
这个程序将值 5 绑定到变量 x，然后将 x 的值复制并赋值给变量 y。现在栈中将有两个值 5。此情况中的数据是"基本数据"类型的数据，不需要存储到堆中，仅在栈中的数据的"移动"方式是直接复制，这不会花费更长的时间或更多的存储空间。
"基本数据"类型有这些：
- 所有整数类型，例如 i32 、 u32 、 i64 等。
- 布尔类型 bool，值为 true 或 false 。
- 所有浮点类型，f32 和 f64。
- 字符类型 char。
- 仅包含以上类型数据的元组（Tuples）。
  
#### 堆中数据的移动
**堆中数据赋值只有栈中的数据被修改。**这个和JS中的引用类型赋值很像了。

```rs
let s1 = String::from("hello"); // 类似 js 中的 new String()
let s2 = s1;
```
1. 第一步产生一个 String 对象，值为 "hello"。其中 "hello" 可以认为是类似于长度不确定的数据，需要在**堆中存储**。
2. 第二步的情况略有不同：
<img src="../notes/images/img01.png" width="240px">

如图所示：两个 String 对象在栈中，每个 String 对象都有一个指针指向堆中的 "hello" 字符串。在给 s2 赋值时，只有栈中的数据被复制了，堆中的字符串依然还是原来的字符串。</br>
当变量超出范围时，Rust 自动调用释放资源函数并清理该变量的堆内存。但是 s1 和 s2 都被释放的话堆区中的 "hello" 被释放两次，这是不被系统允许的。为了确保安全，在给 s2 赋值后 s1 已经无效了。在把 s1 的值赋给 s2 以后 s1 将不可以再被使用。

#### 克隆
Rust会尽可能地降低程序的运行成本，所以默认情况下，长度较大的数据存放在堆中，且采用移动的方式进行数据交互。但如果需要将数据单纯的复制一份以供他用，可以使用数据的第二种交互方式——克隆。
```rs
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();
    println!("s1 = {}, s2 = {}", s1, s2);// s1 = hello, s2 = hello
}
```

#### 函数所有权
如果将变量当作参数传入函数，那么它和移动的效果是一样的:
```rs
fn main() {
    let s = String::from("hello");
    // s 被声明有效
    takes_ownership(s);
    // s 的值被当作参数传入函数
    // 所以可以当作 s 已经被移动，从这里开始已经无效
    let x = 5;
    // x 被声明有效
    makes_copy(x);
    // x 的值被当作参数传入函数
    // 但 x 是基本类型，依然有效
    // 在这里依然可以使用 x 却不能使用 s
} // 函数结束, x 无效, 然后是 s. 但 s 已被移动, 所以不用被释放

fn takes_ownership(some_string: String) {
    // 一个 String 参数 some_string 传入，有效
    println!("{}", some_string);
} // 函数结束, 参数 some_string 在这里释放

fn makes_copy(some_integer: i32) {
    // 一个 i32 参数 some_integer 传入，有效
    println!("{}", some_integer);
} // 函数结束, 参数 some_integer 是基本类型, 无需释放
```

被当作函数返回值的变量所有权将会被移动出函数并返回到调用函数的地方，而不会直接被无效释放:
```rs
fn main() {
    let s1 = gives_ownership();
    // gives_ownership 移动它的返回值到 s1

    let s2 = String::from("hello");
    // s2 被声明有效

    let s3 = takes_and_gives_back(s2);
    // s2 被当作参数移动, s3 获得返回值所有权
} // s3 无效被释放, s2 被移动, s1 无效被释放.

fn gives_ownership() -> String {
    let some_string = String::from("hello");
    // some_string 被声明有效
    return some_string;
    // some_string 被当作返回值移动出函数
}

fn takes_and_gives_back(a_string: String) -> String { 
    // a_string 被声明有效
    a_string  // a_string 被当作返回值移出函数
}
```

### 引用&租借

