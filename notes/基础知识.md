# 基础知识

## 输出到命令行
### 输出字符串
#### 输出方式
Rust 输出文字的方式主要有两种：
2. `print!()`

区别在于:
- `println!`在输出的最后附加输出一个换行符
- `println` 允许打印空的字符串到新的一行，`print!`不允许 

#### println!
```rs
fn main(){
    println!(); // prints just a newline
    println!("hello there!");
    println!("format {{}}");
}
```
总结：
- 使用 `{}` 作占位符
- 可以使用`{number}`指定变量位置
- 使用`{{}}`转义显示字符串`{}`


### 函数定义
``` rs
fn main() {
    let result = another_function(5, 6);
    println!("x + y = {}", result)
}

// 带有返回值的函数
fn another_function(x: i32, y: i32) -> i32 {
    println!("x 的值为 : {}", x);
    println!("y 的值为 : {}", y);
    return x + y;
}
```
总结：
-  Rust不在乎您在何处定义函数，只需在某个地方定义它们即可
-  Rust 是强类型语言，函数参数和函数返回值需要指定类型

### 定义变量
#### 声明变量
如果要声明变量，需要使用 `let` 关键字。例如：
```rs
let a = 123;
```
这样就声明了 `a` 是一个**不可变变量**。在这句声明语句之后，以下三行代码都是被禁止的：
```
a = "abc";
a = 4.56; 
a = 456;
```
- 第一行的错误在于当声明 a 是 123 以后，a 就被确定为整型数字，不能把字符串类型的值赋给它
- 第二行的错误在于自动转换数字精度有损失，Rust 语言不允许精度有损失的自动数据类型转换
- 第三行的错误在于 a 不是个可变变量

#### 使变量变得"可变"
使变量变得"可变"（mutable）只需一个 `mut` 关键字：
```rs
let mut a = 123;
a = 456;
```
#### 常量与不可变变量的区别
既然不可变变量是不可变的，那不就是常量吗？为什么叫变量？</br>
变量和常量还是有区别的。在 Rust 中，以下程序是合法的：
```rs
let a = 123;   // 可以编译，但可能有警告，因为该变量没有被使用
let a = 456;
```
但是如果 a 是常量就不合法：
```rs
const a: i32 = 123;
let a = 456;
```
变量的值可以"重新绑定"，但在"重新绑定"以前不能私自被改变，这样可以确保在每一次"绑定"之后的区域里编译器可以充分的推理程序逻辑。

#### 重影(shadowing)
重影就是指变量的名称可以被重新使用的机制。重影与可变变量的赋值不是一个概念，重影是指用同一个名字重新代表另一个变量实体，其类型、可变属性和值都可以变化。但可变变量赋值仅能发生值的变化。例如：
```rs
fn main() {
    {
        println!("before being shadowed: {}", shadowed_binding);
        // This binding *shadows* the outer one
        let shadowed_binding = "abc";
        println!("shadowed in inner block: {}", shadowed_binding);
    }
    println!("outside inner block: {}", shadowed_binding);
    // This binding *shadows* the previous binding
    let shadowed_binding = 2;
    println!("shadowed in outer block: {}", shadowed_binding);
}
```
输出：
```bash
shadowed in inner block: abc
shadowed in outer block: 2
```
下面这段程序会出错：不能给字符串变量赋整型值。
```rs
let mut s = "123";
s = s.len();
```


### Rust 数据类型